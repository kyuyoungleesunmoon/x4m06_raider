# 재밍 신호 생성 알고리즘 상세 분석

## 📋 개요

본 문서는 X4M06 레이더 재밍 환경 시뮬레이터에서 사용되는 재밍 신호 생성의 구체적인 방법과 알고리즘을 상세히 설명합니다. 차량 레이더 간 상호 간섭 현상을 현실적으로 모델링하기 위해 다양한 재밍 기법을 구현했습니다.

## 🎯 재밍 신호 생성의 목적

### 1. 현실적인 간섭 환경 모사
- **트래픽 잼 환경**: 다수의 차량 레이더가 밀집된 상황
- **다양한 재밍 패턴**: 의도적/비의도적 간섭 신호
- **동적 간섭**: 시간에 따라 변화하는 재밍 특성

### 2. 딥러닝 모델 학습용 데이터
- **Ground Truth**: 깨끗한 신호와 재밍 신호의 정확한 매핑
- **다양성**: 다양한 재밍 시나리오로 모델 강건성 향상
- **확장성**: 새로운 재밍 패턴 쉽게 추가 가능

---

## 🔬 재밍 신호 생성 알고리즘

### 1. 전체 워크플로우

```python
def generate_jammed_signal(self, clean_signal, target_params=None):
    """재밍 신호 생성 전체 프로세스"""
    
    # 1단계: 기본 신호 복사
    jammed_signal = clean_signal.copy()
    
    # 2단계: 재머 개수 결정 (1-8개 범위)
    num_jammers = np.random.randint(*self.config['num_jammers'])
    
    # 3단계: 각 재머별 신호 생성 및 합성
    for _ in range(num_jammers):
        jammer_param = self._generate_jammer_parameters()
        jamming_signal = self._generate_jamming_signal(jammer_param)
        jammed_signal += jamming_signal  # 신호 중첩
    
    return jammed_signal, jammer_params
```

### 2. 재머 파라미터 생성

#### 📊 주요 파라미터
```python
def _generate_jammer_parameters(self):
    """재머 파라미터 무작위 생성"""
    return {
        'power_ratio': np.random.uniform(0.5, 3.0),      # 전력비 (0.5-3배)
        'freq_offset': np.random.uniform(-0.1e9, 0.1e9), # 주파수 오프셋 (±100MHz)
        'time_offset': np.random.uniform(0, 0.8e-3),     # 시간 오프셋 (0-0.8ms)
        'chirp_slope_ratio': np.random.uniform(0.8, 1.2), # 처프 기울기 변화 (±20%)
    }
```

#### 🎛️ 파라미터별 상세 설명

**1) 전력비 (Power Ratio)**
- **범위**: 0.5 ~ 3.0
- **의미**: 재밍 신호가 원본 신호 대비 몇 배 강한지
- **현실성**: 실제 환경에서 근거리 차량은 더 강한 신호, 원거리는 약한 신호
- **수학적 모델**: $P_{jam} = P_{original} \times \text{power\_ratio}$

**2) 주파수 오프셋 (Frequency Offset)**
- **범위**: ±100 MHz
- **의미**: 재머의 중심 주파수가 피해자 레이더와의 차이
- **현실성**: 제조사별, 모델별 주파수 차이 반영
- **수학적 모델**: $f_{jam}(t) = f_{center} + \text{freq\_offset} + \text{slope} \cdot t$

**3) 시간 오프셋 (Time Offset)**
- **범위**: 0 ~ 0.8ms (처프 지속시간 내)
- **의미**: 재머 처프의 시작 시간 차이
- **현실성**: 비동기화된 레이더들의 처프 타이밍 차이
- **수학적 모델**: $t_{jam} = t - \text{time\_offset}$

**4) 처프 기울기 변화 (Chirp Slope Ratio)**
- **범위**: 0.8 ~ 1.2 (±20% 변화)
- **의미**: 재머의 주파수 변화율이 피해자와 다름
- **현실성**: 서로 다른 대역폭을 사용하는 레이더들
- **수학적 모델**: $\text{slope}_{jam} = \text{slope}_{original} \times \text{ratio}$

### 3. 재밍 신호 수학적 생성 과정

#### 🔄 Phase 1: 시간 벡터 조정
```python
# 시간 오프셋 적용
offset_samples = int(jammer_params['time_offset'] * self.config['sampling_rate'])
shifted_time = self.time_vector - jammer_params['time_offset']
```

**수학적 표현**:
$$t_{shifted}[n] = \frac{n}{f_s} - t_{offset}$$

여기서:
- $n$: 샘플 인덱스
- $f_s$: 샘플링 주파수
- $t_{offset}$: 시간 오프셋

#### 🔄 Phase 2: 순간 주파수 계산
```python
# 수정된 처프 기울기
modified_slope = self.chirp_slope * jammer_params['chirp_slope_ratio']

# 재밍 신호의 순간 주파수
jamming_freq = (
    self.config['center_freq'] + 
    jammer_params['freq_offset'] +
    modified_slope * shifted_time
)
```

**수학적 표현**:
$$f_{jam}(t) = f_c + \Delta f + k_{jam} \cdot (t - t_{offset})$$

여기서:
- $f_c$: 중심 주파수
- $\Delta f$: 주파수 오프셋
- $k_{jam} = k_{original} \times \text{ratio}$: 수정된 처프 기울기
- $t_{offset}$: 시간 오프셋

#### 🔄 Phase 3: 위상 및 복소 신호 생성
```python
# 위상 계산 (적분)
phase = 2 * np.pi * np.cumsum(jamming_freq) / self.config['sampling_rate']

# 복소 재밍 신호 생성
jamming_signal = jammer_params['power_ratio'] * np.exp(1j * phase)
```

**수학적 표현**:
$$\phi[n] = \frac{2\pi}{f_s} \sum_{k=0}^{n} f_{jam}[k]$$

$$s_{jam}[n] = A_{jam} \cdot e^{j\phi[n]}$$

여기서:
- $A_{jam} = A_{original} \times \text{power\_ratio}$
- $\phi[n]$: 누적 위상

#### 🔄 Phase 4: 시간 정렬 및 최종 처리
```python
# 시간 오프셋이 있는 경우 순환 이동
if offset_samples > 0:
    jamming_signal = np.roll(jamming_signal, offset_samples)
    jamming_signal[:offset_samples] = 0  # 앞부분 제로 패딩
```

### 4. 다중 재머 합성 알고리즘

#### 🔀 신호 중첩 (Superposition)
```python
jammed_signal = clean_signal.copy()
for i in range(num_jammers):
    jamming_signal_i = generate_jamming_signal(jammer_params_i)
    jammed_signal += jamming_signal_i  # 선형 중첩
```

**수학적 표현**:
$$s_{total}[n] = s_{clean}[n] + \sum_{i=1}^{N} s_{jam,i}[n]$$

여기서:
- $s_{clean}[n]$: 깨끗한 레이더 신호
- $s_{jam,i}[n]$: $i$번째 재머 신호
- $N$: 총 재머 개수

---

## 🎯 재밍 기법 분류 및 구현

### 1. 시간 영역 재밍 (Temporal Jamming)

#### **비동기 처프 재밍 (Asynchronous Chirp Jamming)**
- **원리**: 다른 시간에 시작하는 처프 신호로 간섭
- **구현**: `time_offset` 파라미터 활용
- **효과**: 타겟 탐지 성능 저하, 거짓 알람 증가

```python
# 예시: 0.3ms 지연된 재머
jammer_params = {
    'time_offset': 0.0003,  # 300μs 지연
    'power_ratio': 1.5,
    'freq_offset': 0,
    'chirp_slope_ratio': 1.0
}
```

### 2. 주파수 영역 재밍 (Frequency Domain Jamming)

#### **중심 주파수 편이 재밍 (Center Frequency Shift Jamming)**
- **원리**: 다른 중심 주파수로 동작하는 레이더 신호
- **구현**: `freq_offset` 파라미터 활용
- **효과**: 수신기 대역 내 간섭, 스펙트럼 왜곡

```python
# 예시: 50MHz 상향 편이
jammer_params = {
    'freq_offset': 50e6,   # 50MHz 편이
    'power_ratio': 2.0,
    'time_offset': 0,
    'chirp_slope_ratio': 1.0
}
```

#### **대역폭 변조 재밍 (Bandwidth Modulation Jamming)**
- **원리**: 다른 처프 기울기로 주파수 변화율 차이
- **구현**: `chirp_slope_ratio` 파라미터 활용
- **효과**: 거리 해상도 저하, 측정 정확도 감소

```python
# 예시: 20% 더 가파른 처프
jammer_params = {
    'chirp_slope_ratio': 1.2,  # 20% 증가
    'power_ratio': 1.8,
    'freq_offset': 0,
    'time_offset': 0
}
```

### 3. 전력 영역 재밍 (Power Domain Jamming)

#### **고출력 재밍 (High Power Jamming)**
- **원리**: 매우 강한 신호로 수신기 포화
- **구현**: 높은 `power_ratio` 설정
- **효과**: 타겟 신호 마스킹, 동적 범위 제한

```python
# 예시: 3배 강한 재밍 신호
jammer_params = {
    'power_ratio': 3.0,    # 원신호의 3배
    'freq_offset': 0,
    'time_offset': 0,
    'chirp_slope_ratio': 1.0
}
```

### 4. 복합 재밍 (Composite Jamming)

#### **다중 파라미터 동시 변화**
- **원리**: 여러 재밍 기법을 동시에 적용
- **구현**: 모든 파라미터 동시 변화
- **효과**: 더 현실적이고 복잡한 간섭 환경

```python
# 예시: 복합 재밍
jammer_params = {
    'power_ratio': 2.2,        # 강한 전력
    'freq_offset': -30e6,      # 주파수 하향 편이
    'time_offset': 0.0005,     # 시간 지연
    'chirp_slope_ratio': 0.9   # 느린 처프
}
```

---

## 🔬 구현 세부사항

### 1. 누적 위상 계산의 정확성

#### **이산 시간 적분**
```python
# 연속 시간 위상: φ(t) = 2π ∫ f(τ) dτ
# 이산 시간 근사: φ[n] = (2π/fs) * Σ f[k]
phase = 2 * np.pi * np.cumsum(jamming_freq) / self.config['sampling_rate']
```

**수치적 안정성**:
- `np.cumsum()` 사용으로 누적 오차 최소화
- 부동소수점 정밀도 고려한 구현

### 2. 메모리 효율적인 신호 생성

#### **벡터화 연산**
```python
# 루프 대신 NumPy 벡터 연산 사용
jamming_freq = (
    self.config['center_freq'] + 
    jammer_params['freq_offset'] +
    modified_slope * shifted_time  # 벡터 연산
)
```

### 3. 경계 조건 처리

#### **시간 오프셋 경계 처리**
```python
# 유효하지 않은 시간 영역 제로 패딩
if offset_samples > 0:
    jamming_signal = np.roll(jamming_signal, offset_samples)
    jamming_signal[:offset_samples] = 0
```

---

## 📊 재밍 시나리오 예시

### 시나리오 1: 가벼운 간섭 (Light Interference)
```python
config = {
    'num_jammers': [1, 2],
    'jammer_power_ratio': [0.3, 0.8],
    'freq_offset_range': [-20e6, 20e6],
    'time_offset_range': [0, 0.2e-3]
}
```
- **특징**: 원거리 차량의 약한 간섭
- **영향**: 미미한 성능 저하, 학습용 쉬운 케이스

### 시나리오 2: 중간 간섭 (Moderate Interference)
```python
config = {
    'num_jammers': [2, 4],
    'jammer_power_ratio': [0.8, 2.0],
    'freq_offset_range': [-50e6, 50e6],
    'time_offset_range': [0, 0.5e-3]
}
```
- **특징**: 일반적인 도시 교통 상황
- **영향**: 눈에 띄는 성능 저하, 일반적인 학습 케이스

### 시나리오 3: 강한 간섭 (Strong Interference)
```python
config = {
    'num_jammers': [4, 8],
    'jammer_power_ratio': [1.5, 3.0],
    'freq_offset_range': [-100e6, 100e6],
    'time_offset_range': [0, 0.8e-3]
}
```
- **특징**: 극도로 밀집된 트래픽 잼 상황
- **영향**: 심각한 성능 저하, 어려운 학습 케이스

---

## 🎯 검증 및 품질 관리

### 1. 신호 품질 검증

#### **SNR 계산**
```python
def calculate_jamming_snr(clean_signal, jammed_signal):
    signal_power = np.mean(np.abs(clean_signal)**2)
    noise_power = np.mean(np.abs(jammed_signal - clean_signal)**2)
    snr_db = 10 * np.log10(signal_power / (noise_power + 1e-12))
    return snr_db
```

#### **스펙트럼 순도 확인**
```python
def verify_spectrum_quality(signal, expected_bandwidth):
    spectrum = np.abs(np.fft.fft(signal))
    occupied_bandwidth = calculate_bandwidth(spectrum)
    return abs(occupied_bandwidth - expected_bandwidth) < tolerance
```

### 2. 재밍 효과 정량화

#### **타겟 마스킹 정도**
```python
def measure_target_masking(clean_targets, jammed_targets):
    correlation = np.corrcoef(clean_targets.flatten(), 
                             jammed_targets.flatten())[0,1]
    masking_factor = 1 - correlation  # 0: 마스킹 없음, 1: 완전 마스킹
    return masking_factor
```

---

## 🚀 고급 기능 및 확장성

### 1. 적응형 재밍 (Adaptive Jamming)

```python
def adaptive_jammer_parameters(target_signal_strength):
    """타겟 신호 강도에 따른 적응형 재밍 파라미터"""
    if target_signal_strength < 0.1:
        return {'power_ratio': 0.5}  # 약한 타겟에는 약한 재밍
    elif target_signal_strength > 0.8:
        return {'power_ratio': 2.5}  # 강한 타겟에는 강한 재밍
    else:
        return {'power_ratio': 1.5}  # 중간 수준
```

### 2. 시간 변화 재밍 (Time-Varying Jamming)

```python
def generate_time_varying_jamming(duration, variation_rate):
    """시간에 따라 변화하는 재밍 파라미터"""
    time_steps = int(duration * variation_rate)
    params_sequence = []
    
    for i in range(time_steps):
        params = generate_jammer_parameters()
        # 이전 파라미터와의 연속성 보장
        if i > 0:
            params = smooth_parameter_transition(params_sequence[-1], params)
        params_sequence.append(params)
    
    return params_sequence
```

### 3. 다중 안테나 재밍 (MIMO Jamming)

```python
def generate_mimo_jamming(num_antennas, correlation_matrix):
    """다중 안테나 간 상관관계를 고려한 재밍"""
    independent_jammers = [generate_jamming_signal(params) 
                          for _ in range(num_antennas)]
    
    # 안테나 간 상관관계 적용
    correlated_jammers = apply_correlation(independent_jammers, 
                                         correlation_matrix)
    return correlated_jammers
```

---

## 📈 성능 최적화

### 1. 병렬 처리 구현

```python
from multiprocessing import Pool
import multiprocessing as mp

def generate_jamming_batch_parallel(params_list):
    """다중 재밍 신호 병렬 생성"""
    with Pool(mp.cpu_count()) as pool:
        jamming_signals = pool.map(generate_jamming_signal, params_list)
    return jamming_signals
```

### 2. 메모리 맵 활용

```python
def generate_large_dataset_memory_efficient(num_samples):
    """메모리 효율적인 대용량 데이터셋 생성"""
    # 메모리 맵 파일 생성
    mmap_array = np.memmap('temp_jamming.dat', 
                           dtype='complex64', 
                           mode='w+', 
                           shape=(num_samples, signal_length))
    
    # 배치별로 생성하여 메모리 맵에 저장
    batch_size = 1000
    for i in range(0, num_samples, batch_size):
        batch_signals = generate_jamming_batch(batch_size)
        mmap_array[i:i+batch_size] = batch_signals
    
    return mmap_array
```

---

## 🎯 결론 및 향후 개선 방향

### 현재 구현의 장점

1. **현실적 모델링**: 실제 레이더 간섭 현상을 정확히 모사
2. **다양성**: 다중 재밍 기법의 조합으로 풍부한 데이터셋
3. **확장성**: 새로운 재밍 기법 쉽게 추가 가능
4. **효율성**: 벡터화 연산으로 높은 성능

### 향후 개선 방향

1. **AI 기반 재밍**: 강화학습으로 적응형 재밍 전략 개발
2. **채널 모델 추가**: 실제 전파 환경 반영
3. **하드웨어 검증**: X4M06와의 일치성 검증
4. **실시간 처리**: GPU 가속 및 스트리밍 처리

이러한 상세한 재밍 신호 생성 알고리즘을 통해 현실적이고 다양한 간섭 환경을 시뮬레이션하여, 강건한 딥러닝 모델 개발을 위한 고품질 학습 데이터를 제공할 수 있습니다.