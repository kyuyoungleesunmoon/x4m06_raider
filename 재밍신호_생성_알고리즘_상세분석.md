# ì¬ë° ì‹ í˜¸ ìƒì„± ì•Œê³ ë¦¬ì¦˜ ìƒì„¸ ë¶„ì„

## ğŸ“‹ ê°œìš”

ë³¸ ë¬¸ì„œëŠ” X4M06 ë ˆì´ë” ì¬ë° í™˜ê²½ ì‹œë®¬ë ˆì´í„°ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì¬ë° ì‹ í˜¸ ìƒì„±ì˜ êµ¬ì²´ì ì¸ ë°©ë²•ê³¼ ì•Œê³ ë¦¬ì¦˜ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤. ì°¨ëŸ‰ ë ˆì´ë” ê°„ ìƒí˜¸ ê°„ì„­ í˜„ìƒì„ í˜„ì‹¤ì ìœ¼ë¡œ ëª¨ë¸ë§í•˜ê¸° ìœ„í•´ ë‹¤ì–‘í•œ ì¬ë° ê¸°ë²•ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

## ğŸ¯ ì¬ë° ì‹ í˜¸ ìƒì„±ì˜ ëª©ì 

### 1. í˜„ì‹¤ì ì¸ ê°„ì„­ í™˜ê²½ ëª¨ì‚¬
- **íŠ¸ë˜í”½ ì¼ í™˜ê²½**: ë‹¤ìˆ˜ì˜ ì°¨ëŸ‰ ë ˆì´ë”ê°€ ë°€ì§‘ëœ ìƒí™©
- **ë‹¤ì–‘í•œ ì¬ë° íŒ¨í„´**: ì˜ë„ì /ë¹„ì˜ë„ì  ê°„ì„­ ì‹ í˜¸
- **ë™ì  ê°„ì„­**: ì‹œê°„ì— ë”°ë¼ ë³€í™”í•˜ëŠ” ì¬ë° íŠ¹ì„±

### 2. ë”¥ëŸ¬ë‹ ëª¨ë¸ í•™ìŠµìš© ë°ì´í„°
- **Ground Truth**: ê¹¨ë—í•œ ì‹ í˜¸ì™€ ì¬ë° ì‹ í˜¸ì˜ ì •í™•í•œ ë§¤í•‘
- **ë‹¤ì–‘ì„±**: ë‹¤ì–‘í•œ ì¬ë° ì‹œë‚˜ë¦¬ì˜¤ë¡œ ëª¨ë¸ ê°•ê±´ì„± í–¥ìƒ
- **í™•ì¥ì„±**: ìƒˆë¡œìš´ ì¬ë° íŒ¨í„´ ì‰½ê²Œ ì¶”ê°€ ê°€ëŠ¥

---

## ğŸ”¬ ì¬ë° ì‹ í˜¸ ìƒì„± ì•Œê³ ë¦¬ì¦˜

### 1. ì „ì²´ ì›Œí¬í”Œë¡œìš°

```python
def generate_jammed_signal(self, clean_signal, target_params=None):
    """ì¬ë° ì‹ í˜¸ ìƒì„± ì „ì²´ í”„ë¡œì„¸ìŠ¤"""
    
    # 1ë‹¨ê³„: ê¸°ë³¸ ì‹ í˜¸ ë³µì‚¬
    jammed_signal = clean_signal.copy()
    
    # 2ë‹¨ê³„: ì¬ë¨¸ ê°œìˆ˜ ê²°ì • (1-8ê°œ ë²”ìœ„)
    num_jammers = np.random.randint(*self.config['num_jammers'])
    
    # 3ë‹¨ê³„: ê° ì¬ë¨¸ë³„ ì‹ í˜¸ ìƒì„± ë° í•©ì„±
    for _ in range(num_jammers):
        jammer_param = self._generate_jammer_parameters()
        jamming_signal = self._generate_jamming_signal(jammer_param)
        jammed_signal += jamming_signal  # ì‹ í˜¸ ì¤‘ì²©
    
    return jammed_signal, jammer_params
```

### 2. ì¬ë¨¸ íŒŒë¼ë¯¸í„° ìƒì„±

#### ğŸ“Š ì£¼ìš” íŒŒë¼ë¯¸í„°
```python
def _generate_jammer_parameters(self):
    """ì¬ë¨¸ íŒŒë¼ë¯¸í„° ë¬´ì‘ìœ„ ìƒì„±"""
    return {
        'power_ratio': np.random.uniform(0.5, 3.0),      # ì „ë ¥ë¹„ (0.5-3ë°°)
        'freq_offset': np.random.uniform(-0.1e9, 0.1e9), # ì£¼íŒŒìˆ˜ ì˜¤í”„ì…‹ (Â±100MHz)
        'time_offset': np.random.uniform(0, 0.8e-3),     # ì‹œê°„ ì˜¤í”„ì…‹ (0-0.8ms)
        'chirp_slope_ratio': np.random.uniform(0.8, 1.2), # ì²˜í”„ ê¸°ìš¸ê¸° ë³€í™” (Â±20%)
    }
```

#### ğŸ›ï¸ íŒŒë¼ë¯¸í„°ë³„ ìƒì„¸ ì„¤ëª…

**1) ì „ë ¥ë¹„ (Power Ratio)**
- **ë²”ìœ„**: 0.5 ~ 3.0
- **ì˜ë¯¸**: ì¬ë° ì‹ í˜¸ê°€ ì›ë³¸ ì‹ í˜¸ ëŒ€ë¹„ ëª‡ ë°° ê°•í•œì§€
- **í˜„ì‹¤ì„±**: ì‹¤ì œ í™˜ê²½ì—ì„œ ê·¼ê±°ë¦¬ ì°¨ëŸ‰ì€ ë” ê°•í•œ ì‹ í˜¸, ì›ê±°ë¦¬ëŠ” ì•½í•œ ì‹ í˜¸
- **ìˆ˜í•™ì  ëª¨ë¸**: $P_{jam} = P_{original} \times \text{power\_ratio}$

**2) ì£¼íŒŒìˆ˜ ì˜¤í”„ì…‹ (Frequency Offset)**
- **ë²”ìœ„**: Â±100 MHz
- **ì˜ë¯¸**: ì¬ë¨¸ì˜ ì¤‘ì‹¬ ì£¼íŒŒìˆ˜ê°€ í”¼í•´ì ë ˆì´ë”ì™€ì˜ ì°¨ì´
- **í˜„ì‹¤ì„±**: ì œì¡°ì‚¬ë³„, ëª¨ë¸ë³„ ì£¼íŒŒìˆ˜ ì°¨ì´ ë°˜ì˜
- **ìˆ˜í•™ì  ëª¨ë¸**: $f_{jam}(t) = f_{center} + \text{freq\_offset} + \text{slope} \cdot t$

**3) ì‹œê°„ ì˜¤í”„ì…‹ (Time Offset)**
- **ë²”ìœ„**: 0 ~ 0.8ms (ì²˜í”„ ì§€ì†ì‹œê°„ ë‚´)
- **ì˜ë¯¸**: ì¬ë¨¸ ì²˜í”„ì˜ ì‹œì‘ ì‹œê°„ ì°¨ì´
- **í˜„ì‹¤ì„±**: ë¹„ë™ê¸°í™”ëœ ë ˆì´ë”ë“¤ì˜ ì²˜í”„ íƒ€ì´ë° ì°¨ì´
- **ìˆ˜í•™ì  ëª¨ë¸**: $t_{jam} = t - \text{time\_offset}$

**4) ì²˜í”„ ê¸°ìš¸ê¸° ë³€í™” (Chirp Slope Ratio)**
- **ë²”ìœ„**: 0.8 ~ 1.2 (Â±20% ë³€í™”)
- **ì˜ë¯¸**: ì¬ë¨¸ì˜ ì£¼íŒŒìˆ˜ ë³€í™”ìœ¨ì´ í”¼í•´ìì™€ ë‹¤ë¦„
- **í˜„ì‹¤ì„±**: ì„œë¡œ ë‹¤ë¥¸ ëŒ€ì—­í­ì„ ì‚¬ìš©í•˜ëŠ” ë ˆì´ë”ë“¤
- **ìˆ˜í•™ì  ëª¨ë¸**: $\text{slope}_{jam} = \text{slope}_{original} \times \text{ratio}$

### 3. ì¬ë° ì‹ í˜¸ ìˆ˜í•™ì  ìƒì„± ê³¼ì •

#### ğŸ”„ Phase 1: ì‹œê°„ ë²¡í„° ì¡°ì •
```python
# ì‹œê°„ ì˜¤í”„ì…‹ ì ìš©
offset_samples = int(jammer_params['time_offset'] * self.config['sampling_rate'])
shifted_time = self.time_vector - jammer_params['time_offset']
```

**ìˆ˜í•™ì  í‘œí˜„**:
$$t_{shifted}[n] = \frac{n}{f_s} - t_{offset}$$

ì—¬ê¸°ì„œ:
- $n$: ìƒ˜í”Œ ì¸ë±ìŠ¤
- $f_s$: ìƒ˜í”Œë§ ì£¼íŒŒìˆ˜
- $t_{offset}$: ì‹œê°„ ì˜¤í”„ì…‹

#### ğŸ”„ Phase 2: ìˆœê°„ ì£¼íŒŒìˆ˜ ê³„ì‚°
```python
# ìˆ˜ì •ëœ ì²˜í”„ ê¸°ìš¸ê¸°
modified_slope = self.chirp_slope * jammer_params['chirp_slope_ratio']

# ì¬ë° ì‹ í˜¸ì˜ ìˆœê°„ ì£¼íŒŒìˆ˜
jamming_freq = (
    self.config['center_freq'] + 
    jammer_params['freq_offset'] +
    modified_slope * shifted_time
)
```

**ìˆ˜í•™ì  í‘œí˜„**:
$$f_{jam}(t) = f_c + \Delta f + k_{jam} \cdot (t - t_{offset})$$

ì—¬ê¸°ì„œ:
- $f_c$: ì¤‘ì‹¬ ì£¼íŒŒìˆ˜
- $\Delta f$: ì£¼íŒŒìˆ˜ ì˜¤í”„ì…‹
- $k_{jam} = k_{original} \times \text{ratio}$: ìˆ˜ì •ëœ ì²˜í”„ ê¸°ìš¸ê¸°
- $t_{offset}$: ì‹œê°„ ì˜¤í”„ì…‹

#### ğŸ”„ Phase 3: ìœ„ìƒ ë° ë³µì†Œ ì‹ í˜¸ ìƒì„±
```python
# ìœ„ìƒ ê³„ì‚° (ì ë¶„)
phase = 2 * np.pi * np.cumsum(jamming_freq) / self.config['sampling_rate']

# ë³µì†Œ ì¬ë° ì‹ í˜¸ ìƒì„±
jamming_signal = jammer_params['power_ratio'] * np.exp(1j * phase)
```

**ìˆ˜í•™ì  í‘œí˜„**:
$$\phi[n] = \frac{2\pi}{f_s} \sum_{k=0}^{n} f_{jam}[k]$$

$$s_{jam}[n] = A_{jam} \cdot e^{j\phi[n]}$$

ì—¬ê¸°ì„œ:
- $A_{jam} = A_{original} \times \text{power\_ratio}$
- $\phi[n]$: ëˆ„ì  ìœ„ìƒ

#### ğŸ”„ Phase 4: ì‹œê°„ ì •ë ¬ ë° ìµœì¢… ì²˜ë¦¬
```python
# ì‹œê°„ ì˜¤í”„ì…‹ì´ ìˆëŠ” ê²½ìš° ìˆœí™˜ ì´ë™
if offset_samples > 0:
    jamming_signal = np.roll(jamming_signal, offset_samples)
    jamming_signal[:offset_samples] = 0  # ì•ë¶€ë¶„ ì œë¡œ íŒ¨ë”©
```

### 4. ë‹¤ì¤‘ ì¬ë¨¸ í•©ì„± ì•Œê³ ë¦¬ì¦˜

#### ğŸ”€ ì‹ í˜¸ ì¤‘ì²© (Superposition)
```python
jammed_signal = clean_signal.copy()
for i in range(num_jammers):
    jamming_signal_i = generate_jamming_signal(jammer_params_i)
    jammed_signal += jamming_signal_i  # ì„ í˜• ì¤‘ì²©
```

**ìˆ˜í•™ì  í‘œí˜„**:
$$s_{total}[n] = s_{clean}[n] + \sum_{i=1}^{N} s_{jam,i}[n]$$

ì—¬ê¸°ì„œ:
- $s_{clean}[n]$: ê¹¨ë—í•œ ë ˆì´ë” ì‹ í˜¸
- $s_{jam,i}[n]$: $i$ë²ˆì§¸ ì¬ë¨¸ ì‹ í˜¸
- $N$: ì´ ì¬ë¨¸ ê°œìˆ˜

---

## ğŸ¯ ì¬ë° ê¸°ë²• ë¶„ë¥˜ ë° êµ¬í˜„

### 1. ì‹œê°„ ì˜ì—­ ì¬ë° (Temporal Jamming)

#### **ë¹„ë™ê¸° ì²˜í”„ ì¬ë° (Asynchronous Chirp Jamming)**
- **ì›ë¦¬**: ë‹¤ë¥¸ ì‹œê°„ì— ì‹œì‘í•˜ëŠ” ì²˜í”„ ì‹ í˜¸ë¡œ ê°„ì„­
- **êµ¬í˜„**: `time_offset` íŒŒë¼ë¯¸í„° í™œìš©
- **íš¨ê³¼**: íƒ€ê²Ÿ íƒì§€ ì„±ëŠ¥ ì €í•˜, ê±°ì§“ ì•ŒëŒ ì¦ê°€

```python
# ì˜ˆì‹œ: 0.3ms ì§€ì—°ëœ ì¬ë¨¸
jammer_params = {
    'time_offset': 0.0003,  # 300Î¼s ì§€ì—°
    'power_ratio': 1.5,
    'freq_offset': 0,
    'chirp_slope_ratio': 1.0
}
```

### 2. ì£¼íŒŒìˆ˜ ì˜ì—­ ì¬ë° (Frequency Domain Jamming)

#### **ì¤‘ì‹¬ ì£¼íŒŒìˆ˜ í¸ì´ ì¬ë° (Center Frequency Shift Jamming)**
- **ì›ë¦¬**: ë‹¤ë¥¸ ì¤‘ì‹¬ ì£¼íŒŒìˆ˜ë¡œ ë™ì‘í•˜ëŠ” ë ˆì´ë” ì‹ í˜¸
- **êµ¬í˜„**: `freq_offset` íŒŒë¼ë¯¸í„° í™œìš©
- **íš¨ê³¼**: ìˆ˜ì‹ ê¸° ëŒ€ì—­ ë‚´ ê°„ì„­, ìŠ¤í™íŠ¸ëŸ¼ ì™œê³¡

```python
# ì˜ˆì‹œ: 50MHz ìƒí–¥ í¸ì´
jammer_params = {
    'freq_offset': 50e6,   # 50MHz í¸ì´
    'power_ratio': 2.0,
    'time_offset': 0,
    'chirp_slope_ratio': 1.0
}
```

#### **ëŒ€ì—­í­ ë³€ì¡° ì¬ë° (Bandwidth Modulation Jamming)**
- **ì›ë¦¬**: ë‹¤ë¥¸ ì²˜í”„ ê¸°ìš¸ê¸°ë¡œ ì£¼íŒŒìˆ˜ ë³€í™”ìœ¨ ì°¨ì´
- **êµ¬í˜„**: `chirp_slope_ratio` íŒŒë¼ë¯¸í„° í™œìš©
- **íš¨ê³¼**: ê±°ë¦¬ í•´ìƒë„ ì €í•˜, ì¸¡ì • ì •í™•ë„ ê°ì†Œ

```python
# ì˜ˆì‹œ: 20% ë” ê°€íŒŒë¥¸ ì²˜í”„
jammer_params = {
    'chirp_slope_ratio': 1.2,  # 20% ì¦ê°€
    'power_ratio': 1.8,
    'freq_offset': 0,
    'time_offset': 0
}
```

### 3. ì „ë ¥ ì˜ì—­ ì¬ë° (Power Domain Jamming)

#### **ê³ ì¶œë ¥ ì¬ë° (High Power Jamming)**
- **ì›ë¦¬**: ë§¤ìš° ê°•í•œ ì‹ í˜¸ë¡œ ìˆ˜ì‹ ê¸° í¬í™”
- **êµ¬í˜„**: ë†’ì€ `power_ratio` ì„¤ì •
- **íš¨ê³¼**: íƒ€ê²Ÿ ì‹ í˜¸ ë§ˆìŠ¤í‚¹, ë™ì  ë²”ìœ„ ì œí•œ

```python
# ì˜ˆì‹œ: 3ë°° ê°•í•œ ì¬ë° ì‹ í˜¸
jammer_params = {
    'power_ratio': 3.0,    # ì›ì‹ í˜¸ì˜ 3ë°°
    'freq_offset': 0,
    'time_offset': 0,
    'chirp_slope_ratio': 1.0
}
```

### 4. ë³µí•© ì¬ë° (Composite Jamming)

#### **ë‹¤ì¤‘ íŒŒë¼ë¯¸í„° ë™ì‹œ ë³€í™”**
- **ì›ë¦¬**: ì—¬ëŸ¬ ì¬ë° ê¸°ë²•ì„ ë™ì‹œì— ì ìš©
- **êµ¬í˜„**: ëª¨ë“  íŒŒë¼ë¯¸í„° ë™ì‹œ ë³€í™”
- **íš¨ê³¼**: ë” í˜„ì‹¤ì ì´ê³  ë³µì¡í•œ ê°„ì„­ í™˜ê²½

```python
# ì˜ˆì‹œ: ë³µí•© ì¬ë°
jammer_params = {
    'power_ratio': 2.2,        # ê°•í•œ ì „ë ¥
    'freq_offset': -30e6,      # ì£¼íŒŒìˆ˜ í•˜í–¥ í¸ì´
    'time_offset': 0.0005,     # ì‹œê°„ ì§€ì—°
    'chirp_slope_ratio': 0.9   # ëŠë¦° ì²˜í”„
}
```

---

## ğŸ”¬ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­

### 1. ëˆ„ì  ìœ„ìƒ ê³„ì‚°ì˜ ì •í™•ì„±

#### **ì´ì‚° ì‹œê°„ ì ë¶„**
```python
# ì—°ì† ì‹œê°„ ìœ„ìƒ: Ï†(t) = 2Ï€ âˆ« f(Ï„) dÏ„
# ì´ì‚° ì‹œê°„ ê·¼ì‚¬: Ï†[n] = (2Ï€/fs) * Î£ f[k]
phase = 2 * np.pi * np.cumsum(jamming_freq) / self.config['sampling_rate']
```

**ìˆ˜ì¹˜ì  ì•ˆì •ì„±**:
- `np.cumsum()` ì‚¬ìš©ìœ¼ë¡œ ëˆ„ì  ì˜¤ì°¨ ìµœì†Œí™”
- ë¶€ë™ì†Œìˆ˜ì  ì •ë°€ë„ ê³ ë ¤í•œ êµ¬í˜„

### 2. ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ì‹ í˜¸ ìƒì„±

#### **ë²¡í„°í™” ì—°ì‚°**
```python
# ë£¨í”„ ëŒ€ì‹  NumPy ë²¡í„° ì—°ì‚° ì‚¬ìš©
jamming_freq = (
    self.config['center_freq'] + 
    jammer_params['freq_offset'] +
    modified_slope * shifted_time  # ë²¡í„° ì—°ì‚°
)
```

### 3. ê²½ê³„ ì¡°ê±´ ì²˜ë¦¬

#### **ì‹œê°„ ì˜¤í”„ì…‹ ê²½ê³„ ì²˜ë¦¬**
```python
# ìœ íš¨í•˜ì§€ ì•Šì€ ì‹œê°„ ì˜ì—­ ì œë¡œ íŒ¨ë”©
if offset_samples > 0:
    jamming_signal = np.roll(jamming_signal, offset_samples)
    jamming_signal[:offset_samples] = 0
```

---

## ğŸ“Š ì¬ë° ì‹œë‚˜ë¦¬ì˜¤ ì˜ˆì‹œ

### ì‹œë‚˜ë¦¬ì˜¤ 1: ê°€ë²¼ìš´ ê°„ì„­ (Light Interference)
```python
config = {
    'num_jammers': [1, 2],
    'jammer_power_ratio': [0.3, 0.8],
    'freq_offset_range': [-20e6, 20e6],
    'time_offset_range': [0, 0.2e-3]
}
```
- **íŠ¹ì§•**: ì›ê±°ë¦¬ ì°¨ëŸ‰ì˜ ì•½í•œ ê°„ì„­
- **ì˜í–¥**: ë¯¸ë¯¸í•œ ì„±ëŠ¥ ì €í•˜, í•™ìŠµìš© ì‰¬ìš´ ì¼€ì´ìŠ¤

### ì‹œë‚˜ë¦¬ì˜¤ 2: ì¤‘ê°„ ê°„ì„­ (Moderate Interference)
```python
config = {
    'num_jammers': [2, 4],
    'jammer_power_ratio': [0.8, 2.0],
    'freq_offset_range': [-50e6, 50e6],
    'time_offset_range': [0, 0.5e-3]
}
```
- **íŠ¹ì§•**: ì¼ë°˜ì ì¸ ë„ì‹œ êµí†µ ìƒí™©
- **ì˜í–¥**: ëˆˆì— ë„ëŠ” ì„±ëŠ¥ ì €í•˜, ì¼ë°˜ì ì¸ í•™ìŠµ ì¼€ì´ìŠ¤

### ì‹œë‚˜ë¦¬ì˜¤ 3: ê°•í•œ ê°„ì„­ (Strong Interference)
```python
config = {
    'num_jammers': [4, 8],
    'jammer_power_ratio': [1.5, 3.0],
    'freq_offset_range': [-100e6, 100e6],
    'time_offset_range': [0, 0.8e-3]
}
```
- **íŠ¹ì§•**: ê·¹ë„ë¡œ ë°€ì§‘ëœ íŠ¸ë˜í”½ ì¼ ìƒí™©
- **ì˜í–¥**: ì‹¬ê°í•œ ì„±ëŠ¥ ì €í•˜, ì–´ë ¤ìš´ í•™ìŠµ ì¼€ì´ìŠ¤

---

## ğŸ¯ ê²€ì¦ ë° í’ˆì§ˆ ê´€ë¦¬

### 1. ì‹ í˜¸ í’ˆì§ˆ ê²€ì¦

#### **SNR ê³„ì‚°**
```python
def calculate_jamming_snr(clean_signal, jammed_signal):
    signal_power = np.mean(np.abs(clean_signal)**2)
    noise_power = np.mean(np.abs(jammed_signal - clean_signal)**2)
    snr_db = 10 * np.log10(signal_power / (noise_power + 1e-12))
    return snr_db
```

#### **ìŠ¤í™íŠ¸ëŸ¼ ìˆœë„ í™•ì¸**
```python
def verify_spectrum_quality(signal, expected_bandwidth):
    spectrum = np.abs(np.fft.fft(signal))
    occupied_bandwidth = calculate_bandwidth(spectrum)
    return abs(occupied_bandwidth - expected_bandwidth) < tolerance
```

### 2. ì¬ë° íš¨ê³¼ ì •ëŸ‰í™”

#### **íƒ€ê²Ÿ ë§ˆìŠ¤í‚¹ ì •ë„**
```python
def measure_target_masking(clean_targets, jammed_targets):
    correlation = np.corrcoef(clean_targets.flatten(), 
                             jammed_targets.flatten())[0,1]
    masking_factor = 1 - correlation  # 0: ë§ˆìŠ¤í‚¹ ì—†ìŒ, 1: ì™„ì „ ë§ˆìŠ¤í‚¹
    return masking_factor
```

---

## ğŸš€ ê³ ê¸‰ ê¸°ëŠ¥ ë° í™•ì¥ì„±

### 1. ì ì‘í˜• ì¬ë° (Adaptive Jamming)

```python
def adaptive_jammer_parameters(target_signal_strength):
    """íƒ€ê²Ÿ ì‹ í˜¸ ê°•ë„ì— ë”°ë¥¸ ì ì‘í˜• ì¬ë° íŒŒë¼ë¯¸í„°"""
    if target_signal_strength < 0.1:
        return {'power_ratio': 0.5}  # ì•½í•œ íƒ€ê²Ÿì—ëŠ” ì•½í•œ ì¬ë°
    elif target_signal_strength > 0.8:
        return {'power_ratio': 2.5}  # ê°•í•œ íƒ€ê²Ÿì—ëŠ” ê°•í•œ ì¬ë°
    else:
        return {'power_ratio': 1.5}  # ì¤‘ê°„ ìˆ˜ì¤€
```

### 2. ì‹œê°„ ë³€í™” ì¬ë° (Time-Varying Jamming)

```python
def generate_time_varying_jamming(duration, variation_rate):
    """ì‹œê°„ì— ë”°ë¼ ë³€í™”í•˜ëŠ” ì¬ë° íŒŒë¼ë¯¸í„°"""
    time_steps = int(duration * variation_rate)
    params_sequence = []
    
    for i in range(time_steps):
        params = generate_jammer_parameters()
        # ì´ì „ íŒŒë¼ë¯¸í„°ì™€ì˜ ì—°ì†ì„± ë³´ì¥
        if i > 0:
            params = smooth_parameter_transition(params_sequence[-1], params)
        params_sequence.append(params)
    
    return params_sequence
```

### 3. ë‹¤ì¤‘ ì•ˆí…Œë‚˜ ì¬ë° (MIMO Jamming)

```python
def generate_mimo_jamming(num_antennas, correlation_matrix):
    """ë‹¤ì¤‘ ì•ˆí…Œë‚˜ ê°„ ìƒê´€ê´€ê³„ë¥¼ ê³ ë ¤í•œ ì¬ë°"""
    independent_jammers = [generate_jamming_signal(params) 
                          for _ in range(num_antennas)]
    
    # ì•ˆí…Œë‚˜ ê°„ ìƒê´€ê´€ê³„ ì ìš©
    correlated_jammers = apply_correlation(independent_jammers, 
                                         correlation_matrix)
    return correlated_jammers
```

---

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### 1. ë³‘ë ¬ ì²˜ë¦¬ êµ¬í˜„

```python
from multiprocessing import Pool
import multiprocessing as mp

def generate_jamming_batch_parallel(params_list):
    """ë‹¤ì¤‘ ì¬ë° ì‹ í˜¸ ë³‘ë ¬ ìƒì„±"""
    with Pool(mp.cpu_count()) as pool:
        jamming_signals = pool.map(generate_jamming_signal, params_list)
    return jamming_signals
```

### 2. ë©”ëª¨ë¦¬ ë§µ í™œìš©

```python
def generate_large_dataset_memory_efficient(num_samples):
    """ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ëŒ€ìš©ëŸ‰ ë°ì´í„°ì…‹ ìƒì„±"""
    # ë©”ëª¨ë¦¬ ë§µ íŒŒì¼ ìƒì„±
    mmap_array = np.memmap('temp_jamming.dat', 
                           dtype='complex64', 
                           mode='w+', 
                           shape=(num_samples, signal_length))
    
    # ë°°ì¹˜ë³„ë¡œ ìƒì„±í•˜ì—¬ ë©”ëª¨ë¦¬ ë§µì— ì €ì¥
    batch_size = 1000
    for i in range(0, num_samples, batch_size):
        batch_signals = generate_jamming_batch(batch_size)
        mmap_array[i:i+batch_size] = batch_signals
    
    return mmap_array
```

---

## ğŸ¯ ê²°ë¡  ë° í–¥í›„ ê°œì„  ë°©í–¥

### í˜„ì¬ êµ¬í˜„ì˜ ì¥ì 

1. **í˜„ì‹¤ì  ëª¨ë¸ë§**: ì‹¤ì œ ë ˆì´ë” ê°„ì„­ í˜„ìƒì„ ì •í™•íˆ ëª¨ì‚¬
2. **ë‹¤ì–‘ì„±**: ë‹¤ì¤‘ ì¬ë° ê¸°ë²•ì˜ ì¡°í•©ìœ¼ë¡œ í’ë¶€í•œ ë°ì´í„°ì…‹
3. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ì¬ë° ê¸°ë²• ì‰½ê²Œ ì¶”ê°€ ê°€ëŠ¥
4. **íš¨ìœ¨ì„±**: ë²¡í„°í™” ì—°ì‚°ìœ¼ë¡œ ë†’ì€ ì„±ëŠ¥

### í–¥í›„ ê°œì„  ë°©í–¥

1. **AI ê¸°ë°˜ ì¬ë°**: ê°•í™”í•™ìŠµìœ¼ë¡œ ì ì‘í˜• ì¬ë° ì „ëµ ê°œë°œ
2. **ì±„ë„ ëª¨ë¸ ì¶”ê°€**: ì‹¤ì œ ì „íŒŒ í™˜ê²½ ë°˜ì˜
3. **í•˜ë“œì›¨ì–´ ê²€ì¦**: X4M06ì™€ì˜ ì¼ì¹˜ì„± ê²€ì¦
4. **ì‹¤ì‹œê°„ ì²˜ë¦¬**: GPU ê°€ì† ë° ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬

ì´ëŸ¬í•œ ìƒì„¸í•œ ì¬ë° ì‹ í˜¸ ìƒì„± ì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ í˜„ì‹¤ì ì´ê³  ë‹¤ì–‘í•œ ê°„ì„­ í™˜ê²½ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ì—¬, ê°•ê±´í•œ ë”¥ëŸ¬ë‹ ëª¨ë¸ ê°œë°œì„ ìœ„í•œ ê³ í’ˆì§ˆ í•™ìŠµ ë°ì´í„°ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.